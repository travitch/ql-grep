use crate::query::val_type::Type;

/// Abstract the representation of expressions so that the same core IR can be
/// used at multiple translation stages
pub trait Repr
where
    <Self as Repr>::Type: Eq,
    <Self as Repr>::Type: PartialEq,
    <Self as Repr>::Type: Clone,
    <Self as Repr>::Type: std::fmt::Debug,
{
    /// The type (of types) assigned to each expression
    type Type;
}

/// The raw syntax before type checking
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Syntax;

#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub struct Untyped;

impl Repr for Syntax {
    type Type = Untyped;
}

/// The IR after type checking
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Typed;

impl Repr for Typed {
    type Type = Type;
}

/// A compiled regular expression with its original string
///
/// The original string is used for comparisons, which are not supported on regular expressions.
#[derive(Debug, Clone)]
pub struct CachedRegex(pub String, pub regex::Regex);

#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Constant {
    Boolean(bool),
    Integer(i32),
    String_(String),
    Regex(CachedRegex),
}

impl PartialEq for CachedRegex {
    fn eq(&self, other: &CachedRegex) -> bool {
        self.0 == other.0
    }
}

impl Eq for CachedRegex {}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct VarDecl {
    pub type_: Type,
    pub name: String,
}

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum CompOp {
    LT,
    LE,
    GT,
    GE,
}

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum EqualityOp {
    EQ,
    NE,
}

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum AggregateOp {
    Count,
}

#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Expr_<R: Repr> {
    /// A constant value appearing in a query
    ConstantExpr(Constant),
    /// References to previously-declared variables
    VarRef(String),
    /// An expression node that binds a variable to one of a number of different
    /// relational values (provided by the expression)
    ///
    /// This is not generated by the parser. Instead, it is introduced by the
    /// query planner whenever an equality expression acts as a binder (rather
    /// than a simple scalar assertion). Separating this out makes the
    /// compiler's job a bit easier, as this node represents explicit iteration
    /// over relations.
    Bind {
        /// The variable bound in this expression
        bound_var: VarDecl,
        /// The relational expression that provides the values to bind
        relation_expr: Box<Expr<R>>,
        /// The expression to be evaluated under each variable binding
        evaluated_expr: Box<Expr<R>>,
    },
    /// A comparison between two expressions
    ///
    /// This represents the Ord operations; Eq is handled by
    /// `EqualityComparison`.  This is supported for integer types.
    RelationalComparison {
        lhs: Box<Expr<R>>,
        op: CompOp,
        rhs: Box<Expr<R>>,
    },
    /// Equality between terms
    ///
    /// This is supported for all scalars
    EqualityComparison {
        lhs: Box<Expr<R>>,
        op: EqualityOp,
        rhs: Box<Expr<R>>
    },
    /// A conjunction of two boolean expressions
    LogicalConjunction {
        lhs: Box<Expr<R>>,
        rhs: Box<Expr<R>>,
    },
    /// A disjunction of two boolean expressions
    LogicalDisjunction {
        lhs: Box<Expr<R>>,
        rhs: Box<Expr<R>>,
    },
    /// A method called in a base object, with a list of arguments
    QualifiedAccess {
        base: Box<Expr<R>>,
        method_name: String,
        operands: Vec<Expr<R>>,
    },
    // FIXME: Make this explicit and eliminate the aggregate constructor
    //
    // Count(Box<Expr<R>>),
    Aggregate {
        op: AggregateOp,
        operands: Vec<AsExpr<R>>
    },
}

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Expr<R: Repr> {
    pub expr: Expr_<R>,
    pub type_: R::Type,
}

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AsExpr<R: Repr> {
    pub expr: Expr<R>,
    pub ident: Option<String>,
}

/// A top-level select statement
#[derive(Debug, Eq, PartialEq)]
pub struct Select<R: Repr> {
    /// The expression to evaluate and return
    pub select_exprs: Vec<AsExpr<R>>,
    /// The where clause, if any
    pub where_formula: Expr<R>,
    /// A possibly empty list of variable declarations
    pub var_decls: Vec<VarDecl>,
}
